#ifndef RAYTRACING_HLSL
#define RAYTRACING_HLSL

#include "Raytracing_common.hlsl"

RadiancePayload TraceRadianceRay(in Ray ray, in uint CurRayRecursionDepth, in uint MaxRecursionDepth, float tMin, float tMax, bool cullNonOpaque, bool cullBackFace)
{
    RadiancePayload rayPayload = (RadiancePayload) 0;

    rayPayload.rayRecursionDepth = CurRayRecursionDepth + 1;
    rayPayload.radiance = 0;
	
    if (CurRayRecursionDepth >= MaxRecursionDepth)
    {
        rayPayload.radiance = float3(1, 1, 1);
        return rayPayload;
    }

	// Set the ray's extents.
    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    rayDesc.TMin = tMin;
    rayDesc.TMax = tMax;

    uint rayFlags = 0;
    if (cullNonOpaque)
    {
        rayFlags |= RAY_FLAG_CULL_NON_OPAQUE;
    }
    if (cullBackFace)
    {
        rayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
    }
    // TraceRay(Scene, rayFlags, ~0, 0, 2, 0, rayDesc, rayPayload); // radiance
	// TraceRay(Scene, rayFlags, ~0, 1, 2, 1, rayDesc, shadowPayload); // shadow
	
    //void TraceRay(RaytracingAccelerationStructure AccelerationStructure,
    //      uint RayFlags,
    //      uint InstanceInclusionMask,
    //      uint RayContributionToHitGroupIndex,
    //      uint MultiplierForGeometryContributionToHitGroupIndex,  //stride
    //      uint MissShaderIndex,
    //      RayDesc Ray,
    //      inout payload_t Payload);
    TraceRay(Scene, rayFlags, ~0, 0, 1, 0, rayDesc, rayPayload);

    return rayPayload;
}
[shader("raygeneration")]
void MyRaygenShader_RadianceRay()
{
    uint2 launchIndex = DispatchRaysIndex().xy;
    uint2 launchDim = DispatchRaysDimensions().xy;

    float2 xy = launchIndex.xy + 0.5f; // center in the middle of the pixel.
    float2 screenPos = xy / launchDim.xy * 2.0 - 1.0;
	
    float3 orig = float3(screenPos.xy, 0);
    float3 dir = float3(0, 0, 1);
    Ray ray =
    {
        orig,
		dir
    };
    uint CurRayRecursionDepth = 0;
    bool cullNonOpaque = false;
    bool cullBackFace = false;
    RadiancePayload rayPayload = TraceRadianceRay(ray, CurRayRecursionDepth, g_MaxRadianceRayRecursionDepth, NEAR_PLANE, FAR_PLANE, cullNonOpaque, cullBackFace);
	
    g_OutputDiffuse[launchIndex.xy] = float4(rayPayload.radiance, 1);
    g_OutputDepth[launchIndex.xy] = rayPayload.depth;
}
[shader("closesthit")]
void MyClosestHitShader_RadianceRay(inout RadiancePayload rayPayload, in BuiltInTriangleIntersectionAttributes attr)
{
    float3 hitPosition = HitWorldPosition();
	
    rayPayload.depth = hitPosition.z;
    rayPayload.radiance = float3(1, 1, 0);
}
[shader("miss")]
void MyMissShader_RadianceRay(inout RadiancePayload rayPayload)
{
    // rayPayload.radiance = float3(0, 0, 0);
    // rayPayload.depth = 1.2;
}

[shader("anyhit")]
void MyAnyHitShader_RadianceRay(inout RadiancePayload payload, in BuiltInTriangleIntersectionAttributes attr)
{
    float3 hitPosition = HitWorldPosition();

	// Get the base index of the triangle's first 16 bit index.
    uint InstID = InstanceID();
    uint SystemInstIndex = InstanceIndex(); // The autogenerated index of the current instance in the top-level structure.
    
}
#endif // RAYTRACING_HLSL
