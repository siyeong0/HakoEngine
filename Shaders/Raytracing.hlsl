#ifndef RAYTRACING_HLSL
#define RAYTRACING_HLSL

#include "Raytracing_common.hlsl"

RadiancePayload TraceRadianceRay(in Ray ray, in uint CurRayRecursionDepth, in uint MaxRecursionDepth, float tMin, float tMax, bool cullNonOpaque, bool cullBackFace)
{
    RadiancePayload rayPayload = (RadiancePayload) 0;

    rayPayload.rayRecursionDepth = CurRayRecursionDepth + 1;
    rayPayload.radiance = 0;
	
    if (CurRayRecursionDepth >= MaxRecursionDepth)
    {
        rayPayload.radiance = float3(1, 1, 1);
        return rayPayload;
    }

	// Set the ray's extents.
    RayDesc rayDesc;
    rayDesc.Origin = ray.origin;
    rayDesc.Direction = ray.direction;
    rayDesc.TMin = tMin;
    rayDesc.TMax = tMax;

    uint rayFlags = 0;
    if (cullNonOpaque)
    {
        rayFlags |= RAY_FLAG_CULL_NON_OPAQUE;
    }
    if (cullBackFace)
    {
        rayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
    }
    // TraceRay(Scene, rayFlags, ~0, 0, 2, 0, rayDesc, rayPayload); // radiance
	// TraceRay(Scene, rayFlags, ~0, 1, 2, 1, rayDesc, shadowPayload); // shadow
	
    //void TraceRay(RaytracingAccelerationStructure AccelerationStructure,
    //      uint RayFlags,
    //      uint InstanceInclusionMask,
    //      uint RayContributionToHitGroupIndex,
    //      uint MultiplierForGeometryContributionToHitGroupIndex,  //stride
    //      uint MissShaderIndex,
    //      RayDesc Ray,
    //      inout payload_t Payload);
    TraceRay(Scene, rayFlags, ~0, 0, 1, 0, rayDesc, rayPayload);

    return rayPayload;
}
[shader("raygeneration")]
void MyRaygenShader_RadianceRay()
{
    uint2 launchIndex = DispatchRaysIndex().xy;
    uint2 launchDim = DispatchRaysDimensions().xy;

    float2 xy = launchIndex.xy + 0.5f; // center in the middle of the pixel.
    float2 screenPos = xy / launchDim.xy * 2.0 - 1.0;
	
    float3 orig = float3(screenPos.xy, 0);
    float3 dir = float3(0, 0, 1);
    Ray ray =
    {
        orig,
		dir
    };
    uint CurRayRecursionDepth = 0;
    bool cullNonOpaque = false;
    bool cullBackFace = false;
    RadiancePayload rayPayload = TraceRadianceRay(ray, CurRayRecursionDepth, g_MaxRadianceRayRecursionDepth, NEAR_PLANE, FAR_PLANE, cullNonOpaque, cullBackFace);
	
    g_OutputDiffuse[launchIndex.xy] = float4(rayPayload.radiance, 1);
    g_OutputDepth[launchIndex.xy] = rayPayload.depth;
}

[shader("closesthit")]
void MyClosestHitShader_RadianceRay(inout RadiancePayload rayPayload, in BuiltInTriangleIntersectionAttributes attr)
{
    float3 hitPosition = HitWorldPosition();
    uint instanceID = InstanceID(); // The instance ID as specified in the instance desc.
    uint systemInstanceIndex = InstanceIndex(); // The autogenerated index of the current instance in the top-level structure.
    
    uint baseIndex = PrimitiveIndex() * g_TriangleIndexStride; // The base index of the hit triangle's first 16 bit index.
    uint3 indices = Load3x16BitIndices(baseIndex);
    
    // Get vertex attributes.
    float2 vertexUV[3] =
    {
        l_Vertices[indices[0]].UV,
        l_Vertices[indices[1]].UV,
        l_Vertices[indices[2]].UV
    };
    float3 vertexNormal[3] =
    {
        l_Vertices[indices[0]].Normal,
        l_Vertices[indices[1]].Normal,
        l_Vertices[indices[2]].Normal
    };
    float3 vertexTangent[3] =
    {
        l_Vertices[indices[0]].Tangent,
        l_Vertices[indices[1]].Tangent,
        l_Vertices[indices[2]].Tangent
    };
    
    float2 currTexCoord = HitAttribute(vertexUV, attr);
    float4 texDiffuse = l_DiffuseTexture.SampleLevel(g_SamplerPoint, currTexCoord, 0);
    float3 localNormal = HitAttribute(vertexNormal, attr);
    float3 worldNormal = normalize(mul(localNormal, (float3x3) ObjectToWorld4x3())); // TODO: like Standard.hlsl. use InverseTranspose?
    
    rayPayload.depth = hitPosition.z;
    rayPayload.radiance = texDiffuse;
}

[shader("miss")]
void MyMissShader_RadianceRay(inout RadiancePayload rayPayload)
{
    rayPayload.radiance = float3(0, 0, 1);
    rayPayload.depth = 1.2;
}

[shader("anyhit")]
void MyAnyHitShader_RadianceRay(inout RadiancePayload payload, in BuiltInTriangleIntersectionAttributes attr)
{
    float3 hitPosition = HitWorldPosition();

    uint instanceID = InstanceID(); // The instance ID as specified in the instance desc.
    uint systemInstanceIndex = InstanceIndex(); // The autogenerated index of the current instance in the top-level structure.
}
#endif // RAYTRACING_HLSL
